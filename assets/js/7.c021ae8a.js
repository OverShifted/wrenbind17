(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{190:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"call-wren-and-pass-around-variables"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-wren-and-pass-around-variables","aria-hidden":"true"}},[t._v("#")]),t._v(" Call Wren and pass around variables")]),t._v(" "),a("h2",{attrs:{id:"example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example","aria-hidden":"true"}},[t._v("#")]),t._v(" Example")]),t._v(" "),a("p",[t._v("Consider the following program below:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<wrenbind17/wrenbind17.hpp>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" wren "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" wrenbind17"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Alias")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" argc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("argv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("string code "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token raw-string string"}},[t._v('R"(\n        class Utils {\n            static add(x, b) {\n                return x + b\n            }\n        }\n    )"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Create new VM")]),t._v("\n    wren"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("VM vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// Runs the code from the std::string as a "main" module')]),t._v("\n    vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("runFromSource")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"main"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" code"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Find class Main in module main")]),t._v("\n    wren"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("Variable mainClass "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("find")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"main"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Utils"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Find function main() in class Main")]),t._v("\n    wren"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("Method add "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mainClass"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"add(_, _)"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Execute the function")]),t._v("\n    wren"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("ReturnValue res "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Checks if the return value is an integer")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// In Wren, integers, floats, longs, doubles, are all the same!")]),t._v("\n    res"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("is"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("         "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// returns true")]),t._v("\n    res"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("is"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// returns true")]),t._v("\n    res"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("is"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// returns false")]),t._v("\n    res"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("is"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// returns false")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Prints 30")]),t._v("\n    std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Result: "')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" res"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("as"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("endl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Too call the correct method, you first have to find the class inside of a specific module. When executing a piece of code, you specify the name of the module, in this case "),a("code",[t._v("main")]),t._v(". Then, after the code has been executed, all of the classes and variables are defined in the VM of that particular module. So, we first have to find the class. This can be done by calling "),a("code",[t._v("wren::VM::find(module_name, class_name)")]),t._v(". Then, we can find any specific function we want by calling "),a("code",[t._v("wren::Variable::func(signature)")]),t._v(". The signature you pass into the "),a("code",[t._v("func")]),t._v(" must match the correct Wren method. Signatures such as "),a("code",[t._v("add()")]),t._v(" nor "),a("code",[t._v("add(_)")]),t._v(" won't work, because the Wren function has two arguments. Only "),a("code",[t._v("add(_, _)")]),t._v(" will work. If the signature is invalid, or the method simply does not exist, an exception "),a("code",[t._v("wren::NotFound")]),t._v(" is thrown.")]),t._v(" "),a("p",[t._v("Passing variables to Wren is simply done by passing the variables into the "),a("code",[t._v("operator(...)")]),t._v(". If the number of variables does not match the signature, it will throw an exception "),a("code",[t._v("wren::Exception")]),t._v(". The result of the execution is capured as "),a("code",[t._v("wren::ReturnValue")]),t._v(". This can hold anything from nullptr up to a C++ class. To check the contents, simply call the "),a("code",[t._v("is<...>()")]),t._v(" method, or you get the contents, call the "),a("code",[t._v("as<...>()")]),t._v(" method.")]),t._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",[t._v("Warning!")]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("wren::Variable")]),t._v(", "),a("code",[t._v("wren::Method")]),t._v(", and "),a("code",[t._v("wren::ReturnValue")]),t._v(" contain handles from Wren that extend the liveness of the variables/methods they hold. You must dispose of them before the VM shuts down. Otherwise the destructor of these classes may cause undefined behavior, even a segmentation fault. Be sure that "),a("code",[t._v("wren::VM")]),t._v(" is the last thing to be destroyed.")])]),t._v(" "),a("h2",{attrs:{id:"types-you-can-pass-around"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#types-you-can-pass-around","aria-hidden":"true"}},[t._v("#")]),t._v(" Types you can pass around")]),t._v(" "),a("p",[t._v("You can pass around any integer between 8 and 64 bits (int8, uint8, int, short, char, unsigned char, etc...), floats, doubles, booleans, and std::strings. These are simple types and will be represented as Wren's built in types. But, Wren has only 64-bit floating point (double). It does not have integers. Therefore, all integers are converted to doubles. Any other types (C++ classes) must be explicitly added to Wren. ("),a("router-link",{attrs:{to:"/docs/bind_cpp_class.html"}},[t._v("see this guide")]),t._v(")")],1),t._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",[t._v("Warning!")]),t._v(" "),a("p",[t._v("Don't use const char*! It will result in compilation error or it will just thrown a bad cast exception during runtime. Use std::string.")])])])},[],!1,null,null,null);s.default=e.exports}}]);