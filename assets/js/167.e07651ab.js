(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{429:function(t,e,a){"use strict";a.r(e);var s=a(38),r=Object(s.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"tutorial-external-files-and-modularity"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tutorial-external-files-and-modularity","aria-hidden":"true"}},[t._v("#")]),t._v(" Tutorial: External files and modularity")]),t._v(" "),a("p",[t._v("Other source code files can be imported into Wren, but this depends on the lookup paths. When creating an instance of the VM, the first argument is a list of paths to use for lookup. Example below:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("vector"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" paths "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"some/relative/path"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C:/absolute/path"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nwren"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("VM "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("vm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("paths"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("div",{staticClass:"warning custom-block"},[a("p",[t._v("Warning!")]),t._v(" "),a("p",[t._v("The default value of the VM constructor is "),a("code",[t._v('{"./"}')]),t._v(". This means that by default the VM will look for files relative to your working directory! If there is a file "),a("code",[t._v("libs/mylib.wren")]),t._v(" in your working directory, and in the Wren you load it as "),a("code",[t._v('import "libs/mylib" for XYZ')]),t._v(" then it will load it from your working directory as "),a("code",[t._v('"your_working_dir" + "./" + "libs/mylib.wren"')]),t._v(".")])]),t._v(" "),a("p",[t._v("So how does the lookup paths work? Consider the following example:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("myprogram/\n    app.exe\n    data/\n        main.wren\n        libA.wren\n        utils/\n            libB.wren\n")])])]),a("p",[t._v("So you have three files: "),a("code",[t._v("data/main.wren")]),t._v(", "),a("code",[t._v("data/libA.wren")]),t._v(", and "),a("code",[t._v("data/utils/libB.wren")]),t._v(". Now, inside of your main you might have something like this:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// File: data/main.wren")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"libA"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XYZ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// Won\'t work because "libA.wren" does not exist in "./"')]),t._v("\n")])])]),a("p",[t._v("And let's assume you are running "),a("code",[t._v("app.exe")]),t._v(" with working directory of "),a("code",[t._v("myprogram/")]),t._v(". The above code will fail. Why? Because the default argument for "),a("code",[t._v("wren::VM")]),t._v(" paths is "),a("code",[t._v('{"./"}')]),t._v(". Meaning, it will look for "),a("code",[t._v("libA.wren")]),t._v(" relatively to "),a("code",[t._v("./")]),t._v(" which is relative to your working directory.")]),t._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",[t._v("Relative imports do not work due to the design of Wren! Absolute imports are the only way!")])]),t._v(" "),a("p",[t._v("What you need to do is to put an absolute path to the "),a("code",[t._v("myprogram/data")]),t._v(" folder into your "),a("code",[t._v('wren::VM vm({"C:/whatever/apps/myprogram/data"});')]),t._v(". Only then the import mechanism will work. The import system works in a way that it will append the import string into your lookup paths and checks wether the file exists. If the file exists, it will load it, ignoring other files. This also means that if you have multiple files.")]),t._v(" "),a("p",[t._v("What about importing "),a("code",[t._v("utils/libB.wren")]),t._v("? The following will work:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// File: data/libA.wren")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"utils/libB"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XYZ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// looks for "C:/whatever/apps/myprogram/data/" + "utils/libB.wren"')]),t._v("\n")])])]),a("p",[t._v("Imports from a parent folder work too, because everything is absolute path anyway.")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// File: data/utils/libB.wren")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"libA"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XYZ")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// looks for "C:/whatever/apps/myprogram/data/" + "libA.wren"')]),t._v("\n")])])]),a("h2",{attrs:{id:"file-ambiguity"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#file-ambiguity","aria-hidden":"true"}},[t._v("#")]),t._v(" File ambiguity")]),t._v(" "),a("p",[t._v("Consider files: "),a("code",[t._v("test/lib/A.wren")]),t._v(" and "),a("code",[t._v("main/lib/A.wren")]),t._v(". Putting lookup paths for "),a("code",[t._v("test")]),t._v(" and "),a("code",[t._v("main")]),t._v(" folders and then loading it as "),a("code",[t._v('import "lib/A"')]),t._v(" will load the "),a("code",[t._v("lib/A.wren")]),t._v(" from the first folder the file exists in. The order of the lookup paths does matter!")])])},[],!1,null,null,null);e.default=r.exports}}]);