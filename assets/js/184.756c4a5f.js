(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{381:function(e,t,o){"use strict";o.r(t);var s=o(0),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"tutorial-lifetime-of-objects-passed-into-wren"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tutorial-lifetime-of-objects-passed-into-wren","aria-hidden":"true"}},[e._v("#")]),e._v(" Tutorial: Lifetime of objects passed into Wren")]),e._v(" "),o("p",[e._v("In the previous section we have discussed what happens with objects that are returned from Wren, but what about the other way around?")]),e._v(" "),o("p",[e._v("It's very simple in this case. There are only 4 different scenarios:")]),e._v(" "),o("ul",[o("li",[e._v("Pass class "),o("code",[e._v("Foo")]),e._v(" as a value. The Wren will create a copy of it.")]),e._v(" "),o("li",[e._v("Pass class "),o("code",[e._v("Foo*")]),e._v(" as a pointer. The instance will be wrapped into "),o("code",[e._v("std::shared_ptr<Foo>")]),e._v(" "),o("strong",[e._v("but won't free it")]),e._v(". So it will be alive inside of Wren until you free the instance on C++ side. Wren's garbage collector won't free this instance.")]),e._v(" "),o("li",[e._v("Pass class "),o("code",[e._v("Foo&")]),e._v(" as a reference. "),o("strong",[e._v("Copy will be created if you are calling a Wren function. But if you are calling a C++ function that returns a "),o("code",[e._v("Foo&")]),e._v(" reference, it will be handled exactly as a pointer.")])]),e._v(" "),o("li",[e._v("Pass class "),o("code",[e._v("const Foo&")]),e._v(" as a constant reference. Exactly same as "),o("code",[e._v("Foo&")]),e._v(" from previous point.")]),e._v(" "),o("li",[e._v("Pass class "),o("code",[e._v("std::shared_ptr<Foo>")]),e._v(" as a shared pointer. The lifetime of this object will be extended by Wren. So both C++ and Wren will manage the lifetime of this. If you lose the shared pointer on C++ side, and Wren holds the instance, then it will be freed by Wren's garbage collector only when the instance inside of Wren gets no longer used/referenced.")])])])}),[],!1,null,null,null);t.default=a.exports}}]);