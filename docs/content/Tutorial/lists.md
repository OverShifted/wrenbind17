---
title: Lists
weight: 150
---

## Pre-made STL vector and list bindings

Lists are not implemented in this library natively. However, they are added as an optional classes that you can use. The `std::vector<T>` and `std::list<T>` are implemented via `wren::StdVectorBindings<T>::bind(module, name);` and as `wren::StdListBindings<T>::bind(module, name);`. For example:

```cpp
Wren::VM vm;
auto& m = vm.module("std");
wren::StdVectorBindings<int>::bind(m, "VectorInt");
```

And the Wren code:

```js
import "std" for VectorInt

var v = VectorInt.new()
v.add(42) // Push new value
v.insert(-1, 20) // Insert at the end
v.contains(42) // returns true
v.pop() // Remove last element and returns it
v.count // Returns the length/size
v.size() // Same as the count
v.clear() // Removes everything
v.removeAt(-2) // Removes the 2nd element from back and returns it
v[0] = 43 // Set specific index (negative indexes not supported!)
System.print("Second: %(v[1])") // Get specific index (no negative indexes!)
for (item in v) { // Supports iteration
    System.print("Item: %(item)") // Prints individual elements
}
```

{{% notice note %}}
I highly recommend going through `wrenbind17/include/wrenbind17/std.hpp` to see how exactly this works.
{{% /notice %}}

## Custom lists

If you read through the [Iterator Protocol](http://wren.io/control-flow.html#the-iterator-protocol) section on official Wren documentation, then you know that you need to implement at least 2 functions:

* `iterate(_)`
* `iteratorValue(_)`

Let's implement all of them for `std::vector<int>`! First we need the `iterate()` function. This function must accept already existing iterator or a null. To do this, we will use `std::variant` and an external function that will be bind to Wren via `funcExt`. 

```cpp
typedef typename std::vector<int>::iterator Iterator;
typedef typename std::vector<int> Vector;

static std::variant<bool, Iterator> iterate(
        Vector& self, // this
        std::variant<std::nullptr_t, Iterator> other
    ) {

    // Check if "other" variant is NOT nullptr
    if (other.index() == 1) {
        // Get the 2nd template, the iterator
        auto it = std::get<Iterator>(other);
        ++it;
        if (it != self.end()) {
            // Return the next position
            return {it};
        }

        // Once we reach the end, we must return false
        return {false};
    } else {
        // No iterator supplied, the variant is null,
        // then return the start of the vector
        return {self.begin()};
    }
}
```

Next, we need the `iteratorValue()` function. This one is very simple:

```cpp
static int iteratorValue(Vector& self, std::shared_ptr<Iterator> other) {
    // You could replace the shared_ptr with a simple copy value.
    // But that depends on you.
    auto& it = *other;
    return *it;
}
```

And then bind it!

```cpp
wren::VM vm;
auto& m = vm.module("std");
auto& cls = m.klass<Vector>("VectorInt");
cls.ctor<>();
cls.funcExt<&iterate>("iterate");
cls.funcExt<&iteratorValue>("iteratorValue");
```

That's all you need to implement your custom list and use it inside of a for loop!

## Custom lists and operator []

To get the operator [] working, you need two functions to set and to get the index.

```cpp
typedef typename std::vector<int>::iterator Iterator;
typedef typename std::vector<int> Vector;

static void setIndex(Vector& self, size_t index, int value) {
    self[index] = value;
}

static int getIndex(Vector& self, size_t index) {
    return self[index];
}
```

And then bind it!

```cpp
wren::VM vm;
auto& m = vm.module("std");
auto& cls = m.klass<Vector>("VectorInt");
cls.ctor<>();
cls.funcExt<&getIndex>(wren::OPERATOR_GET_INDEX);
cls.funcExt<&setIndex>(wren::OPERATOR_SET_INDEX);
```

The enum values you supply instead of function names will create special bindings for overloading operators. Wren will see the following:

```js
// Autogenerated
class VectorInt {
    ...
    foreign [index]         // Get
    foreign [index]=(other) // Set
}
```
