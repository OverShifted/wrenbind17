---
title: Bind C++ class
weight: 60
---

To bind a C++ class, you will first need to create a new module. Creating a new module is done per VM instance. If you have multiple VMs in your application, they won't share the same modules. You would have to create the module for each of your VM instances. Copying modules between instances is not possible.

```cpp
wren::VM vm;

// Create module called "mymodule"
auto& m = vm.module("mymodule");
```

You can create as many modules as you want. Additionally, calling the method `module(...)` multiple times with the same name won't create duplicates. For example:

```cpp
wren::VM vm;

auto& m0 = vm.module("mymodule");
auto& m1 = vm.module("mymodule");

// m0 and m1 now point to the exact same module
```

{{% notice info %}}
Modules must be used via a reference `auto& m = ...`. Copying modules is not allowed and causes compilation error.
{{% /notice %}}

### Class member functions

Classes are added into the modules in the following way:

```cpp
class Foo {
public:
    Foo(const std::string& msg) {
        ...
    }

    void bar() {

    }

    int baz() const {

    }
};

wren::VM vm;
auto& m = vm.module("mymodule");

// Add class "Foo"
auto& cls = m.klass<Foo>("Foo");

// Define constructor (you can only specify one constructor)
cls.ctor<const std::string&>();

// Add some methods
cls.func<&Foo::bar>("bar");
cls.func<&Foo::baz>("baz");
```

The class functions (methods) are added as a template argument, not as the function argument. This is due to the how Wren is built. Because of this implementation, you will also get extra performance, because the pointers to the class functions are optimized at compile time, there are no lookup maps.

Now inside of your Wren script, you can do the following:

```js
import "mymodule" for Foo

var foo = Foo.new("Message")
foo.bar();
var i = foo.baz();
```

Please note that you don't have to manually create file "mymodule.wren" and add all of your C++ foreign classes into it manually. Everything is automatically generated by the `wren::VM`. You can get the "raw" contents of the module that will be put into Wren by simply calling `.str()` on the module (e.g. `vm.module("mymodule").str();`). This will print the contents of that module as a Wren code with foreign classes.

### Handling function pointer ambiguity

In case you have multiple functions with the same name, you will have to use `static_cast` to explicitly tell the compiler which function you want. For example:

```cpp
class Foo {
    const std::string& getMsg() const;
    std::string& getMsg();
};

wren::VM vm;
auto& m = vm.module("mymodule");
auto& cls = vm.klass<Foo>("Foo");
cls.func<static_cast<const std::string& (*)(void) const>(&Foo::getMsg)>("getMsg");
```

### Static functions

To add a static function, simply call the `funcStatic` instead of `func` as shown below:

```cpp
class Log {
    static void debug(const std::string& text);
    static void error(const std::string& text);
    static void info(const std::string& text);
};

wren::VM vm;
auto& m = vm.module("mymodule");
auto& cls = m.klass<Log>("Log");
cls.funcStatic<&Log::debug>("debug");
cls.funcStatic<&Log::error>("error");
cls.funcStatic<&Log::info>("info");
```

### Via external functions


Suppose you have some C++ class you want to bind to Wren, but you can't modify this class because it is from some other library, for example from STL. Or, you want to add some custom behavior but such C++ method does not exist. In this case, you can do the following:

```cpp
// Custom member function with "self" as this pointer
template<typename T>
bool vectorContains(std::vector<T>& self, const T& value) {
    return std::find(self.begin(), self.end(), value) != self.end();
}

// Custom static function without any "self"
template<typename T>
bool vectorFactory(const T& value) {
    std::vector<T> vec;
    vec.push_back(value);
    return vec;
}

auto& cls = m.klass<std::vector<int>>("VectorInt");
cls.ctor<>();
cls.funcExt<&vectorContains<int>>("contains");
cls.funcStaticExt<&vectorFactory<int>>("factory");
```

```js
import "mymodule" for VectorInt

var a = VectorInt.new()
var b = VectorInt.factory(456) // Calls vectorFactory<T>
a.contains(123) // returns bool
```

"Ext" simply means that this is an external function, and the first parameter **must** accept a reference to the class you are binding. However, static functions do not require this. Do not mistake this with "extern" C++ keyword. It has nothing to do with that. (Maybe there is a better word for it?) Additionally, if you look at the `vectorContains` function from above, there is no "this" pointer because this is not a member function. Instead, the "this" is provided as a custom parameter in the first position. This also works with `propExt` and `propReadonlyExt`, and static via `funcStaticExt`.

## Binding C++ class varialbles

There are two ways how to add C++ class variables to Wren. One is [as variables](#as-variables) and the other way is [as properties](#as-properties). In the end, they will act exactly same in Wren. The only difference is on the C++ side!

### As variables

One way is to have a field and simply bind it to the Wren:

```cpp
struct Vec3 {
    float x = 0;
    float y = 0;
    float z = 0;
};

wren::VM vm;
auto& m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.var<&Vec3::x>("x");
cls.var<&Vec3::y>("y");
cls.var<&Vec3::z>("z");
```

### As properties

Another way is to have a getter and a setter and bind those to the Wren:

```cpp
class Vec3 {
public:
    float getX() const     { return x; }
    void setX(float value) { x = value; }
    float getY() const     { return y; }
    void setY(float value) { y = value; }
    float getZ() const     { return z; }
    void setZ(float value) { z = value; }
private:
    float x = 0;
    float y = 0;
    float z = 0;
};

wren::VM vm;
auto& m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.prop<&Vec3::getX, &Vec3::setX>("x");
cls.prop<&Vec3::getY, &Vec3::setY>("y");
cls.prop<&Vec3::getZ, &Vec3::setZ>("z");
```

### Result

Equivalent wren code for both using `.var<&field>("name")` or `.prop<&getter, &setter>("name")`:

```js
// Autogenerated
foreign class Vec3 {
    construct new () {}
    
    foreign x
    foreign x=(rhs)

    foreign y
    foreign y=(rhs)

    foreign z
    foreign z=(rhs)
}
```

And then simply use it in Wren as:

```js
import "mymodule" for Vec3

var v = Vec3.new()
v.x = 1.23
v.y = 0.0
v.z = 42.42
```

### Read only variables

To bind read-only variables you can use `varReadonly` function. This won't define a Wren setter and therefore the variable can be only read. 

```cpp
class Vec3 {
public:
    Vec3(float x, float y, float z) {...}

    const float x;
    const float y;
    const float z;
};

wren::VM vm;
auto& m = vm.module("mymodule");

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.varReadonly<&Vec3::x>("x");
cls.varReadonly<&Vec3::y>("y");
cls.varReadonly<&Vec3::z>("z");
```

Equivalent wren code:

```js
// Autogenerated
foreign class Vec3 {
    construct new () {}
    
    foreign x

    foreign y

    foreign z
}
```

And then simply use it in Wren as:

```js
import "mymodule" for Vec3

var v = Vec3.new(1.1, 2.3, 3.3)
System.print("X value is: %(v.x)") // ok
v.x = 1.23 // error
```

For read-only properties, you can use `propReadonly` as shown below:

```cpp
// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.propReadonly<&Vec3::getX>("x");
cls.propReadonly<&Vec3::getY>("y");
cls.propReadonly<&Vec3::getZ>("z");
```

### Variables via external functions

Sometimes the property simply does not exist in the C++ class you want to use. So, you somehow need to add this into Wren without changing the original class code. One way to do it is through "external" functions. This is simply a function that is static and **must** accept the first parameter as a reference to the class instance. 

```cpp
static float getVec3X(Vec3& self) {
    return self.x;
}

static float getVec3Y(Vec3& self) { ... }
static float getVec3Z(Vec3& self) { ... }

// Add class "Vec3"
auto& cls = m.klass<Vec3>("Vec3");
cls.ctor<>();
cls.propExtReadonly<&getVec3X>("x");
cls.propExtReadonly<&getVec3Y>("y");
cls.propExtReadonly<&getVec3Z>("z");
```

### Static variables

Static variables in Wren are not supported. However, you could cheat a bit with the following code:

```cpp
class ApplicationGlobals {
public:
    std::string APP_NAME = "Lorem Ipsum Donor";
};

int main() {
    ...

    wren::VM vm(...);
    auto& m = vm.module("mymodule");

    auto& cls = m.klass<ApplicationGlobals>("ApplicationGlobals");
    cls.var<&ApplicationGlobals::APP_NAME>("APP_NAME");
    m.append("var Globals = ApplicationGlobals.new()\n");

    return 0;
}
```

Wren code:


```js
import "mymodule" for Globals

print("Name: %(Globals.APP_NAME)")
```

What does `m.append` do? It allows you to add arbitraty Wren code into the auto generated Wren code from your C++ classes. Anything you will put into the append function will appear at the bottom of the autogenerated code. Calling the append function multiple times is allowed, it will **not** override previous append call. In this case above, the ApplicationGlobals is created as an instance named Globals. So, from the user's perspective in the Wren code, it appears as a static member variable. The name **must start with a capital letter**, otherwise Wren will not allow you to import that variable. 
