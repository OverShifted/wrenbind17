<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial on WrenBind17</title>
    <link>https://matusnovak.github.io/wrenbind17/tutorial/</link>
    <description>Recent content in Tutorial on WrenBind17</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://matusnovak.github.io/wrenbind17/tutorial/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1. Installation</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/install/</guid>
      <description>1. Installation #  You don&amp;rsquo;t need to compile this library. This library is a header only library, all you have to do is to include the #include &amp;lt;wrenbind17/wrenbind17.hpp&amp;gt; header in your C++ project. However, you will need to compile and link the Wren VM, and adding an include path where the &amp;lt;wren.hpp&amp;gt; file is located. To see how to build and use the Wren library, see Getting Started section here from the official Wren documentation.</description>
    </item>
    
    <item>
      <title>10. Fn.new and callbacks</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/fn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/fn/</guid>
      <description>10. Fn.new and callbacks #  Let&amp;rsquo;s say you have a GUI button widget and you want to have a specific action when a user clicks on it.
class GuiButton { public: GuiButton(std::function&amp;lt;bool(int)&amp;gt; func) : func(std::move(func)) { } virtual ~GuiButton() { } bool event(int type) { return func(type); } private: std::function&amp;lt;bool(int)&amp;gt; func; }; And now you would like to create this class in Wren and add some custom Wren function as the callback.</description>
    </item>
    
    <item>
      <title>11. STL Containers</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/stl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/stl/</guid>
      <description>11. STL Containers #  11.1. Optionals #  The std::optional&amp;lt;T&amp;gt; will be converted into a null or the type that it can hold. This also works when you call C++ function from Wren that accepts std::optional&amp;lt;T&amp;gt;. You can either call that function with null or with the type T.
11.1.1. Limitations #  Passing std::optional via non-const reference is not allowed. Also passing as a pointer or a shared pointer does not work either.</description>
    </item>
    
    <item>
      <title>2. Hello World</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/hello_world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/hello_world/</guid>
      <description>2. Hello World #  First, create a wren::VM instance, run the source code, find the method you want to run, and execute the method. In the example below, we are printing out a simple &amp;ldquo;Hello World&amp;rdquo; to the console. It is recommended that you create an alias from wrenbind17 to wren so you don&amp;rsquo;t have to type that many characters every time. I highly encourage you to NOT to use using namespace wrenbind17;!</description>
    </item>
    
    <item>
      <title>3. Call Wren function</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/call_wren/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/call_wren/</guid>
      <description>3. Call Wren function #  3.1. Simple call #  To call a Wren function, you will have to first run the source code. Only then you can use wren::VM::find function to find the class defined in the Wren code. This will give you an object of wren::Variable which can be any Wren variable from the VM. In this case, it&amp;rsquo;s a class. Next, find the method you want to call via wren::Variable::func.</description>
    </item>
    
    <item>
      <title>4. Supported types</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/types/</guid>
      <description>4. Supported types #  4.1. List of supported types and conversion #  This is a list of supported types and how they are converted between C++ and Wren. Not everything can be mapped exactly (for example, integers are casted into doubles), so there are some compromises.
   C++ type Wren type Return value from Any     signed char (int8_t) number (64-bit float) .as&amp;lt;int8_t&amp;gt;()   unsigned char (uint8_t) number (64-bit float) .</description>
    </item>
    
    <item>
      <title>5. Executing from file</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/execute_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/execute_code/</guid>
      <description>5. Executing from file #  Executing Wren code can also be done in the following ways:
// Same as above, specify the module name but instead // of the source code you tell it where the file is located. vm.runFromFile(&amp;#34;main&amp;#34;, &amp;#34;path/to/some/main.wren&amp;#34;); // Run specific module. This module must be an existing file &amp;#34;utils/libB.wren&amp;#34; // in one or more look-up paths specified during creation of wren::Vm vm(...); vm.runFromModule(&amp;#34;utils/libB&amp;#34;); Note
The runFromModule depends on the lookup paths you pass into the wren::VM constructor.</description>
    </item>
    
    <item>
      <title>6. Custom types</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/custom_types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/custom_types/</guid>
      <description>6. Custom types #  Wren supports adding custom types. See official documentation here. This is done via foregin classes that can have member of static functions and fields. All of foreign classes added via WrenBind17 are wrapped in a custom wrapper (wren::detail::ForeignObject&amp;lt;T&amp;gt;) that takes care of handling of instance of your custom C++ type.
In order to use your custom types, you will have to register them as a foreign classes with foreign functions into the Wren VM.</description>
    </item>
    
    <item>
      <title>7. Class operators</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/operators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/operators/</guid>
      <description>7. Class operators #  Operators can be added to your custom types, this is done via the wren::ForeignMethodOperator enumeration.
This is a list of all supported operators by WrenBind17:
   Operator Enum Value     Add (+) OPERATOR_ADD   Subtract (-) OPERATOR_SUB   Multiply (*) OPERATOR_MUL   Divide (/) OPERATOR_DIV   Unary negative (-) OPERATOR_NEG   Modulo (%) OPERATOR_MOD   Equal to (==) OPERATOR_EQUAL   Not equal to (!</description>
    </item>
    
    <item>
      <title>8. Modules and files</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/modules/</guid>
      <description>8. Modules and files #  Wren support modularity (official documentation here), but does not exactly work out of the box. WrenBind17 fills this gap by adding a file load function that works using a list of look-up paths.
If you are familiar with Python, this is almost the same as the Python home path for loading modules.
std::vector&amp;lt;std::string&amp;gt; paths = { &amp;#34;some/relative/path&amp;#34;, &amp;#34;C:/absolute/path&amp;#34; }; wren::VM vm(paths); It is highly advised to use absolute paths.</description>
    </item>
    
    <item>
      <title>9. Customize VM</title>
      <link>https://matusnovak.github.io/wrenbind17/tutorial/customize/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matusnovak.github.io/wrenbind17/tutorial/customize/</guid>
      <description>9. Customize VM #  9.1. Min heap and growth #  To control the minimal heap, heap growth, and initial heap, use the constructor to do so. Example:
#include &amp;lt;wrenbind17/wrenbind17.hpp&amp;gt;namespace wren = wrenbind17; // Alias  int main(...) { // These values are default.  // If you leave the constructor empty, these exact  // values will be used.  // The lookup paths for loading other Wren files  std::vector&amp;lt;std::string&amp;gt; paths = {&amp;#34;.</description>
    </item>
    
  </channel>
</rss>